n = int(input().strip())

# Список для хранения пар (end_minutes, start_minutes)
# Храним в таком порядке (end, start), чтобы удобно сортировать по окончанию.
intervals = []


# Вспомогательная функция: преобразует строку "hh:mm"
# в количество минут с 00:00
def time_to_minutes(t):
    # Разбиваем по : и переводим в целые
    hh, mm = t.split(':')
    return int(hh) * 60 + int(mm)


# Читаем строки с парами времен начала и конца
for _ in range(n):
    s_start, s_end = input().split()
    start = time_to_minutes(s_start)
    end = time_to_minutes(s_end)
    intervals.append((end, start))

# Сортируем интервалы по времени окончания
intervals.sort()

# last_end — время окончания последней выбранной встречи (в минутах).
# Изначально ставим -1 или 0: лучше поставить -1,
#  чтобы встречи, начинающиеся в 0:00,
# могли быть приняты. Но поскольку времена не отрицательные, можно взять 0.
# Чтобы корректно позволить встречу, начавшуюся в 0:00,
#  если last_end = 0 и start == 0,
# условие start >= last_end допускает её — это корректно.
#  Поэтому инициализируем  -1 или 0.
last_end = -1

# Счетчик принятых посетителей
count = 0

# Проходим по отсортированным интервалам и
#  выбираем максимально возможное число невложенных
for end, start in intervals:
    # Если начало текущей встречи не раньше окончания последней принятой
    # (start >= last_end), то мы можем принять этого посетителя.
    # В задаче прямо сказано,
    # что встреча может начинаться точно в момент окончания предыдущей.
    if start >= last_end:
        count += 1
        last_end = end  # обновляем время окончания

print(count)
